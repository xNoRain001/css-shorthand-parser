(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.shorthandParser = factory());
})(this, (function () { 'use strict';

  function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s,
        _e,
        _x,
        _r,
        _arr = [],
        _n = !0,
        _d = !1;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i) return;
          _n = !1;
        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
      } catch (err) {
        _d = !0, _e = err;
      } finally {
        try {
          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var isNumberStr = function isNumberStr(v) {
    return /^\d+$/.test(v);
  };
  var oneValueParser = function oneValueParser(v) {
    if (v === 'initial') {
      return threeValueParser(0, 1, 'auto');
    }
    if (v === 'auto') {
      return threeValueParser(1, 1, 'auto');
    }
    if (v === 'none') {
      return threeValueParser(0, 0, 'auto');
    }
    if (isNumberStr(v)) {
      return threeValueParser(Number(v), 1, "0");
    }
    return threeValueParser(1, 1, v);
  };
  var twoValueParser = function twoValueParser(v1, v2) {
    v1 = Number(v1);
    return isNumberStr(v2) ? threeValueParser(v1, Number(v2), "0") : threeValueParser(v1, 1, v2);
  };
  var threeValueParser = function threeValueParser(v1, v2, v3) {
    v1 = Number(v1);
    v2 = Number(v2);
    return {
      'flex-grow': v1,
      'flex-shrink': v2,
      'flex-basis': v3
    };
  };
  var flexParser = function flexParser(value) {
    var segments = value.split(' ');
    var length = segments.length;
    var _segments = _slicedToArray(segments, 3),
      v1 = _segments[0],
      v2 = _segments[1],
      v3 = _segments[2];
    if (length === 1) {
      return oneValueParser(v1);
    }
    if (length === 2) {
      return twoValueParser(v1, v2);
    }
    return threeValueParser(v1, v2, v3);
  };

  var commonParser = function commonParser(key, value, flagFn, res) {
    var _res = '';
    var segments = value.split(' ');
    for (var i = 0, l = segments.length; i < l; i++) {
      var segment = segments[i];
      if (flagFn(segment)) {
        _res += "".concat(segment, " ");
        // don't use regexp, because '(' and '.'
        value = value.replace(segment, '');
      }
    }
    res[key] = _res ? _res.slice(0, -1) : 'unset';
    // remove unnecessary white space
    value = value.replace(/\s{2,}/g, ' ').trim();
    return value;
  };

  var fontSizeKeywordValues = {
    'xx-small': null,
    'x-small': null,
    small: null,
    medium: null,
    large: null,
    'x-large': null,
    'xx-large': null,
    larger: null,
    smaller: null
  };
  var fontStyleKeywordValues = {
    normal: null,
    italic: null,
    oblique: null
  };
  var fontWeightKeywordValues = {
    normal: null,
    bold: null,
    lighter: null,
    bolder: null
  };
  var borderStyleKeywordValues = {
    hidden: null,
    dotted: null,
    dashed: null,
    solid: null,
    "double": null,
    groove: null,
    ridge: null,
    inset: null,
    outset: null
  };
  var borderWidthKeywordValues = {
    thin: null,
    medium: null,
    thick: null
  };
  var listStyleTypeKeywordValues = {
    disc: null,
    circle: null,
    square: null,
    decimal: null
  };
  var backgroundClipKeywordValues = {
    // text: null,
    'border-box': null,
    'padding-box': null,
    'content-box': null
  };
  var backgroundOriginKeywordValue = {
    'border-box': null,
    'padding-box': null,
    'content-box': null
  };
  var backgroundRepeatKeywordValues = {
    repeat: null,
    space: null,
    round: null,
    'repeat-x': null,
    'repeat-y': null,
    'no-repeat': null
  };
  var listStylePositionKeywordValues = {
    inside: null,
    outside: null
  };
  var animationFillModeKeywordValues = {
    none: null,
    forwards: null,
    backwards: null,
    both: null
  };
  var animationDirectionKeywordValues = {
    normal: null,
    reverse: null,
    alternate: null,
    'alternate-reverse': null
  };
  var animationPlayStateKeywordValues = {
    running: null,
    paused: null
  };
  var backgroundPositionKeywordValues = {
    top: null,
    right: null,
    bottom: null,
    left: null,
    center: null
  };
  var backgroundAttachmentKeywordValues = {
    scroll: null,
    fixed: null,
    local: null
  };
  var animationTimingFunctionKeywordValues = {
    ease: null,
    'ease-in': null,
    'ease-out': null,
    'ease-in-out': null,
    linear: null,
    'step-start': null,
    'step-end': null
  };

  var sizeAndLineHeightParser = function sizeAndLineHeightParser(value, res, segments) {
    for (var i = 0, l = segments.length; i < l; i++) {
      var segment = segments[i];
      var index = segment.indexOf('/');
      if (index !== -1) {
        res['font-size'] = segment.slice(0, index);
        res['line-height'] = segment.slice(index + 1);
        value = value.replace(segment, '');
        break;
      } else if (fontSizeKeywordValues.hasOwnProperty(segment) || /^\d+(.\d+)?[a-z%]+$/.test(segment)) {
        // 12px 13% 3em 4rem 12.5px 13.5% 3.5em 4.5rem
        res['font-size'] = segment;
        value = value.replace(segment, '');
        break;
      }
    }
    return value.replace(/\s{2,}/g, ' ').trim();
  };
  var fontParser = function fontParser(value) {
    var res = {
      'font-size': 'unset',
      'line-height': 'unset',
      // 'font-variant': 'unset',
      'font-weight': 'unset',
      'font-style': 'unset',
      'font-family': 'unset'
    };
    var segments = value.split(' ');
    if (segments.length === 1) {
      res['font-family'] = segments[0];
    } else {
      // at least have font-size and font-family -> font: 13px serief;
      // line-height maybe next to font-size -> font: 13px/2.5 serief;
      value = sizeAndLineHeightParser(value, res, segments);
      var keys = Object.keys(res);
      keys.splice(0, 2); // ignore font-size, line-height

      var flagFnsMap = {
        'font-weight': function fontWeight(v) {
          return fontWeightKeywordValues.hasOwnProperty(v) || /^\d+(\.\d+)?$/.test(v);
        },
        'font-style': function fontStyle(v) {
          // TODO: font-style: oblique 40deg;
          return fontStyleKeywordValues.hasOwnProperty(v);
        },
        'font-family': function fontFamily(v) {
          return v;
        }
      };
      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        if (value) {
          value = commonParser(key, value, flagFnsMap[key], res);
        }
      }
    }
    if (res['font-weight'] === 'normal' && res['font-style'] === 'unset') {
      res['font-style'] = 'normal';
    }
    return res;
  };

  // 0.3s -> 300ms
  // .4s -> 400ms
  // 2.4 -> 2400ms
  var formatTime = function formatTime(value) {
    value = value.replace(/\s?(\d*\.\d+)s/g, function (_, time) {
      if (time[0] === '.') {
        time = "0".concat(time);
      }
      return "".concat(Number(time) * 1000, "ms");
    });
    return value;
  };
  var durationAndDelayParser = function durationAndDelayParser(value, res) {
    value = formatTime(value);
    var counter = 0;

    // remove duration, delay and unmeaning time
    value = value.replace(/\s?(\d+m?s)/g, function (_, $1) {
      if (counter === 2) {
        return '';
      }
      counter++;
      if (counter === 1) {
        res['animation-duration'] = $1;
      } else if (counter === 2) {
        res['animation-delay'] = $1;
      }
      return '';
    });
    return value;
  };
  var animationParser = function animationParser(value) {
    var res = {
      'animation-duration': 'unset',
      'animation-delay': 'unset',
      'animation-timing-function': 'unset',
      'animation-iteration-count': 'unset',
      'animation-direction': 'unset',
      'animation-fill-mode': 'unset',
      'animation-play-state': 'unset',
      'animation-name': 'unset'
    };
    var flagFnsMap = {
      'animation-timing-function': function animationTimingFunction(v) {
        return animationTimingFunctionKeywordValues.hasOwnProperty(v) || /(.*?\(.*?\))/.test(v);
      },
      'animation-iteration-count': function animationIterationCount(v) {
        return v === 'infinite' || !isNaN(Number(v));
      },
      'animation-direction': function animationDirection(v) {
        return animationDirectionKeywordValues.hasOwnProperty(v);
      },
      'animation-fill-mode': function animationFillMode(v) {
        return animationFillModeKeywordValues.hasOwnProperty(v);
      },
      'animation-play-state': function animationPlayState(v) {
        return animationPlayStateKeywordValues.hasOwnProperty(v);
      },
      'animation-name': function animationName(v) {
        return v;
      }
    };
    value = durationAndDelayParser(value, res);
    var keys = Object.keys(res);
    keys.splice(0, 2);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      if (value) {
        value = commonParser(key, value, flagFnsMap[key], res);
      }
    }
    return res;
  };

  var isListStylePosition = function isListStylePosition(v) {
    return listStylePositionKeywordValues.hasOwnProperty(v);
  };
  var isListStyleType = function isListStyleType(v) {
    return listStyleTypeKeywordValues.hasOwnProperty(v);
  };
  var listStyleParser = function listStyleParser(value) {
    var res = {};
    var segments = value.split(' ');
    var length = segments.length;
    res['list-style-type'] = 'none';
    res['list-style-position'] = 'none';
    res['list-style-image'] = 'none';

    // TODO: support one or two value syntax
    if (length < 3) {
      return res;
    }
    for (var i = 0; i < length; i++) {
      var segment = segments[i];
      if (isListStyleType(segment)) {
        res['list-style-type'] = segment;
      } else if (isListStylePosition(segment)) {
        res['list-style-position'] = segment;
      } else {
        res['list-style-image'] = segment;
      }
    }
    return res;
  };

  var clipParser = function clipParser(res) {
    var origin = res['background-origin'];
    var clip = res['background-clip'];
    if (origin !== 'unset' && clip === 'unset') {
      var _origin$split = origin.split(' '),
        _origin$split2 = _slicedToArray(_origin$split, 2),
        originValue = _origin$split2[0],
        clipValue = _origin$split2[1];
      if (clipValue) {
        res['background-origin'] = originValue;
        res['background-clip'] = clipValue;
      } else {
        res['background-clip'] = originValue;
      }
    }
  };
  var positionAndSizeAndColorParser = function positionAndSizeAndColorParser(value, res) {
    var segments = value.split(' ');
    var index = value.indexOf('/');
    if (index !== -1) {
      // at least have background-position and background-size     
      // may be have background-color
      res['background-position'] = value.slice(0, index);
      value = value.slice(index + 1);
      var _value$split = value.split(' '),
        _value$split2 = _slicedToArray(_value$split, 3),
        v1 = _value$split2[0],
        v2 = _value$split2[1],
        v3 = _value$split2[2];
      if (v2) {
        // background-size two-value syntax:
        // background-size: 50% auto;
        // background-size: 3em 25%;
        // background-size: auto 6px;
        // background-size: auto auto;
        if (/\d+.*/.test(v2) || v2 === 'auto') {
          res['background-size'] = "".concat(v1, " ").concat(v2);
          if (v3) {
            res['background-color'] = v3;
          }
        } else {
          res['background-size'] = v1;
          res['background-color'] = v2;
        }
      } else {
        // only background-size
        res['background-size'] = v1;
      }
    } else {
      // must be background-position or background-color  
      var _segments = _slicedToArray(segments, 1),
        _v = _segments[0];
      var isPosition = segments.length === 1 && (
      // TODO: .5% .7px ...
      backgroundPositionKeywordValues.hasOwnProperty(_v) || /^\d+/.test(_v));
      res[isPosition ? 'background-position' : 'background-color'] = _v;
    }
  };
  var backgroundParser = function backgroundParser(value) {
    var res = {
      'background-repeat': 'unset',
      'background-origin': 'unset',
      'background-clip': 'unset',
      'background-attachment': 'unset',
      'background-image': 'unset',
      'background-position': 'unset',
      'background-size': 'unset',
      'background-color': 'unset'
    };
    var flagFnsMap = {
      'background-repeat': function backgroundRepeat(value) {
        return backgroundRepeatKeywordValues.hasOwnProperty(value);
      },
      'background-origin': function backgroundOrigin(value) {
        return backgroundOriginKeywordValue.hasOwnProperty(value);
      },
      'background-clip': function backgroundClip(value) {
        return backgroundClipKeywordValues.hasOwnProperty(value);
      },
      'background-attachment': function backgroundAttachment(value) {
        return backgroundAttachmentKeywordValues.hasOwnProperty(value);
      },
      'background-image': function backgroundImage(value) {
        return /url\(.*?\)/.test(value);
      }
    };
    var keys = Object.keys(res);
    keys.splice(5, 3);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      if (value) {
        value = commonParser(key, value, flagFnsMap[key], res);
      }
    }
    if (value) {
      positionAndSizeAndColorParser(value, res);
    }
    clipParser(res);
    return res;
  };

  var isBorderWidth = function isBorderWidth(v) {
    return borderWidthKeywordValues.hasOwnProperty(v) || /^[0-9]/.test(v[0]);
  };
  var isBorderStyle = function isBorderStyle(v) {
    return borderStyleKeywordValues.hasOwnProperty(v);
  };
  var commonBorderParser = function commonBorderParser(value, prefix) {
    var res = {};
    var segments = value.split(' ');
    var length = segments.length;
    res["".concat(prefix, "-width")] = 'none';
    res["".concat(prefix, "-style")] = 'none';
    res["".concat(prefix, "-color")] = 'none';

    // TODO: support one or two value syntax
    if (length < 3) {
      return res;
    }
    for (var i = 0; i < length; i++) {
      var segment = segments[i];
      if (isBorderWidth(segment)) {
        res["".concat(prefix, "-width")] = segment;
      } else if (isBorderStyle(segment)) {
        res["".concat(prefix, "-style")] = segment;
      } else {
        res["".concat(prefix, "-color")] = segment;
      }
    }
    return res;
  };

  // margin: 10px;
  // margin: 10px 20px;
  // margin: 10px 20px 30px;
  // margin: 10px 20px 30px 40px;
  var commonDirectionParser = function commonDirectionParser(value, prefix, suffix) {
    var res = {};
    var segments = value.split(' ');
    var length = segments.length;
    var _segments = _slicedToArray(segments, 4),
      v1 = _segments[0],
      v2 = _segments[1],
      v3 = _segments[2],
      v4 = _segments[3];
    suffix = suffix ? "-".concat(suffix) : '';
    if (length === 1) {
      res["".concat(prefix, "-top").concat(suffix)] = v1;
      res["".concat(prefix, "-right").concat(suffix)] = v1;
      res["".concat(prefix, "-bottom").concat(suffix)] = v1;
      res["".concat(prefix, "-left").concat(suffix)] = v1;
    } else if (length === 2) {
      res["".concat(prefix, "-top").concat(suffix)] = v1;
      res["".concat(prefix, "-right").concat(suffix)] = v2;
      res["".concat(prefix, "-bottom").concat(suffix)] = v1;
      res["".concat(prefix, "-left").concat(suffix)] = v2;
    } else if (length === 3) {
      res["".concat(prefix, "-top").concat(suffix)] = v1;
      res["".concat(prefix, "-right").concat(suffix)] = v2;
      res["".concat(prefix, "-bottom").concat(suffix)] = v3;
      res["".concat(prefix, "-left").concat(suffix)] = v2;
    } else {
      res["".concat(prefix, "-top").concat(suffix)] = v1;
      res["".concat(prefix, "-right").concat(suffix)] = v2;
      res["".concat(prefix, "-bottom").concat(suffix)] = v3;
      res["".concat(prefix, "-left").concat(suffix)] = v4;
    }
    return res;
  };

  var strategies = {
    margin: function margin(value) {
      return commonDirectionParser(value, 'margin');
    },
    padding: function padding(value) {
      return commonDirectionParser(value, 'padding');
    },
    border: function border(value) {
      return commonBorderParser(value, 'border');
    },
    'border-top': function borderTop(value) {
      return commonBorderParser(value, 'border-top');
    },
    'border-right': function borderRight(value) {
      return commonBorderParser(value, 'border-right');
    },
    'border-bottom': function borderBottom(value) {
      return commonBorderParser(value, 'border-bottom');
    },
    'border-left': function borderLeft(value) {
      return commonBorderParser(value, 'border-left');
    },
    'border-width': function borderWidth(value) {
      return commonDirectionParser(value, 'border', 'width');
    },
    'border-style': function borderStyle(value) {
      return commonDirectionParser(value, 'border', 'style');
    },
    'border-color': function borderColor(value) {
      return commonDirectionParser(value, 'border', 'color');
    },
    'list-style': function listStyle(value) {
      return listStyleParser(value);
    },
    flex: function flex(value) {
      return flexParser(value);
    },
    animation: function animation(value) {
      return animationParser(value);
    },
    background: function background(value) {
      return backgroundParser(value);
    },
    font: function font(value) {
      return fontParser(value);
    } // transition () {},
  };

  var shorthandParser = function shorthandParser(prop, value) {
    value = value.replace(/\s{2,}/g, ' ').replace(/\s?,\s?/g, ',') // rgb( 0 , 0, 0 ) -> rgb( 0,0,0 )
    .replace(/\(\s?/g, '(') // rgb( 0,0,0 ) -> rgb(0,0,0 )
    .replace(/\s?\)/g, ')') // rgb(0,0,0 ) -> rgb(0,0,0)
    .replace(/\s?\/\s?/g, '/'); // background: center / 80% -> background: center/80%

    var straregy = strategies[prop];
    return straregy ? straregy(value) : null;
  };

  return shorthandParser;

}));
